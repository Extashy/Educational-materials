'use strict';

// Задание 1

// 1. Rabbit => true.
// 2. Animal => null.
// 3. Undefined.

// Задание 2

// 1. Решение:

// pockets.__proto__ = bed;
// bed.__proto__ = table;
// table.__proto__ = head;

// Теперь поиск любого свойства будет выполняться по указанному пути: pockets → bed → table → head.

// 2. Быстрее получить значение glasses через head.glasses, 
// так как это свойство находится в самом объекте head и поиск не требует обхода цепочки прототипов. 
// В случае с pockets.glasses нужно было бы пройти по цепочке прототипов pockets → bed → table → head, что занимает больше времени.

// Задание 3

// Ответ: rabbit.

// Задание 4

// При обращении к свойству stomach у объекта lazy происходит поиск в его прототипе hamster, 
// так как у самого объекта это свойство отсутствует. Поскольку speedy добавил элемент в массив stomach, 
// он также отображается и в массиве stomach объекта hamster, который является прототипом для обоих хомяков.

// Чтобы исправить эту ситуацию, можно изменить метод eat объекта hamster следующим образом:

let hamster = {
  stomach: [],

  eat(food) {
    this.stomach = [food]; // создаем новый массив для каждого хомяка
  }
};

// Теперь при вызове метода eat у каждого хомяка будет создаваться новый массив stomach, и изменения одного хомяка не будут влиять на другого.